## 综合方案设计
### 1.系统架构概述
系统分为以下核心模块：
1. 数据采集层：负责从摄像头采集视频片段。
2. 推理层：使用TensorRT对视频片段进行推理。
3. 结果处理层：处理推理结果，检测违规行为。
4. 报警层：推送报警信息。
5. 监控服务：监控任务状态，管理任务分配和负载均衡。
6. Redis：用于存储任务状态、任务池、容器负载等信息。
7. RabbitMQ：用于解耦服务之间的通信。
8. MySQL：用于存储推送记录和算法参数等持久化数据。

### 2. 模块详细设计
#### 2.1 数据采集层
- 功能：
    - 从摄像头采集5秒的视频片段。
    - 将视频片段存储到存储池（SATA）。
    - 将视频片段的地址（存储路径）放入RabbitMQ的任务队列（按照摄像头ID 路由）。
- 实现细节：
    - 每个采图进程负责一个摄像头。
    - 采图进程中的守护线程定期向监控服务汇报状态（摄像头ID、容器hostname、进程PID、最近汇报时间）。
#### 2.2 推理层
- 功能：
    - 从RabbitMQ消费视频地址。
    - 使用TensorRT进行推理，生成结果（摄像头ID + numpy格式的推理结果）。
    - 将推理结果放入RabbitMQ的结果队列（按照摄像头ID 路由）。
- 实现细节：
    - 推理服务可以横向扩展，支持多实例部署。
    - 定期向监控服务汇报状态。
#### 2.3 结果处理层
- 功能：
    - 从RabbitMQ消费推理结果（按照摄像头ID消费）。
    - 进行目标跟踪、检测和违规判断。
    - 如果发现违规，将报警信息放入报警队列(统一队列)。
- 实现细节：
    - 违规判断逻辑需要高效且准确(消费需大于算法推理速度)。
    - 定期向监控服务汇报状态。
#### 2.4 报警层
- 功能：
    - 从报警队列消费报警信息。
    - 获取回放（需要控制回放时间30s）
    - 推送报警信息（通过API）。
    - 将推送记录存储到MySQL。
- 实现细节：
    - 报警信息需要去重和使用ack确认机制，必须保证回放视频录制完成才能移除消息。
    - 是否需要多点部署，保证服务的高可用
#### 2.5 监控服务(注册中心。计划放在浪潮服务器)
- 功能：
    - 提供API接收各个微服务的状态汇报。
    - 监控任务状态，处理超时任务。
    - 管理任务分配和负载均衡。
    - 完成对Redis任务池的管理(用于广播回收的任务)
- 实现细节：
    - 分布式注册中心需要使用Redis存储任务状态、任务池、容器负载等信息。
    - 前期可以考虑在内存做存储容器状态，Redis只是用来做广播消息的组件。
    - 定期检查任务状态，处理超时任务，超时任务提交到任务池、通过Redis广播消息停止对应的进程。
    - 实现任务分配和负载均衡逻辑（任务容器定时获取有没有自己的任务，这里需要加锁（应用锁和分布式锁）NOTE: 替换为接受广播消息，去掉分布式锁）。
#### 2.6 Redis
- 功能：
    - 存储任务状态、任务池、容器负载等信息。
    - 提供分布式锁，确保任务分配的原子性。
- 数据结构：
    - 任务状态表（Hash）：camera_task_status
    - 任务池（List）：camera_task_pool
    - 容器负载表（Hash）：container_load
    - 分布式锁（Key-Value）：task_lock:{camera_id}
#### 2.7 RabbitMQ
- 功能：
    - 解耦服务之间的通信。
    - 提供任务队列、结果队列、报警队列。
#### 2.8 MySQL
- 功能：
    - 存储推送记录和算法参数等持久化数据。

### 3.任务分配与负载均衡
#### 3.1 任务分配机制
- 任务池：
    - 存放待分配的摄像头ID（如cam001、cam002等）。
- 任务抢占：
    - 生产容器定期从任务池中抢任务。
    - 抢到任务后，更新自己的负载信息。
#### 3.2 负载均衡机制
- 容器负载表：
    - 记录每个容器的负载情况（当前监控的摄像头数量）。
- 任务分配策略：
    - 优先将任务分配给负载较轻的容器。
    - 通过Redis的原子操作确保任务分配的公平性。
#### 3.3 详细解释
- 1.任务分配机制
- 任务池：
    - 所有待分配的摄像头ID都存放在Redis的camera_task_pool中。
- 任务抢占：
    - 每个采图容器定期从任务池中抢任务。
    - 抢到任务后，容器会更新自己的负载信息（如当前监控的摄像头数量）。
- 注意：需要加应用锁确保更新负载信息和抢占任务的原子性，避免更新负载信息和抢占任务同时进行
- 2.负载均衡机制
- 容器负载表：
    - 使用Redis的Hash结构记录每个容器的负载情况（如container_load）。
- 任务分配策略：
    - 在抢任务时，容器会检查自己的负载情况。
    - 如果当前负载较轻（如监控的摄像头数量较少），则优先抢任务。
    - 通过Redis的原子操作确保任务分配的公平性。
- 注意：引入（分布式锁）来确保容器抢占任务的原子性。
- 具体步骤如下：
    - 抢任务时加锁：
        - 在抢任务前，先获取分布式锁。
        - 抢到任务后，更新负载信息。
        - 释放分布式锁。
    - 锁的超时机制：
        - 设置锁的过期时间，避免锁被长时间占用。
    - 锁的重试机制：
        - 如果获取锁失败，等待一段时间后重试。

### 4.监控服务的实现
- 4.1 API设计
- 4.2 任务监控逻辑
- 4.3 负载均衡逻辑

### 5.高可用性设计
- 5.1 多实例部署


### 6.部署与运行


### 7.总结
- 数据采集层：采集视频片段，将地址放入RabbitMQ。
- 推理层：消费视频地址，进行推理，将结果放入RabbitMQ。
- 结果处理层：消费推理结果，检测违规行为，将报警信息放入RabbitMQ。
- 报警层：消费报警信息，推送报警，并将推送记录存储到MySQL。
- 监控服务：监控任务状态，管理任务分配和负载均衡。
- Redis：存储任务状态、任务池、容器负载等信息。
- RabbitMQ：解耦服务之间的通信。
- MySQL：存储推送记录和算法参数等持久化数据。